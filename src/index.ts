import {
  Document,
  LayoutRoot,
  Segment,
  Context,
  element,
  root,
  segment,
  LayoutElement,
} from "@localizesh/sdk";
import { Processor, IdGenerator, visitParents } from "@localizesh/sdk";

function convertJsonToMap(
  jsonObj: Record<string, any> | any[],
  parentKey: string = "",
): Record<string, any> {
  let result: Record<string, any> = {};
  const isParentArray = Array.isArray(jsonObj);

  for (const [key, value] of Object.entries(jsonObj)) {
    let newKey = key;
    if (parentKey) {
      newKey = isParentArray ? `${parentKey}..${key}` : `${parentKey}.${key}`;
    }

    if (typeof value === "object" && value !== null) {
      Object.assign(result, convertJsonToMap(value, newKey));
    } else {
      result[newKey] = value;
    }
  }

  return result;
}

function convertMapToJson(rows: { key: string; value: string }[]) {
  const result: any = {};

  rows.forEach((row) => {
    const { key, value } = row;
    const keys = key.split(".").map((str) => str.trim());
    let currentObj: any = result;

    for (let i = 0; i < keys.length - 1; i++) {
      const currentKey = keys[i];

      // Skip the empty key generated by '..'
      if (currentKey === "") continue;

      if (!currentObj[currentKey]) {
        const nextKey = keys[i + 1];
        // If nextKey is empty, it means we are transitioning to an array
        // e.g. "physics" -> "" -> "0"
        if (nextKey === "") {
          currentObj[currentKey] = [];
        } else {
          currentObj[currentKey] = {};
        }
      }

      currentObj = currentObj[currentKey];
    }

    const lastKey: string = keys[keys.length - 1];

    if (Array.isArray(currentObj)) {
      // Use assignment to preserve index position rather than push
      currentObj[Number(lastKey)] = value;
    } else {
      currentObj[lastKey] = value;
    }
  });

  return result;
}

export default class JsonProcessor extends Processor {
  parse(res: string, ctx?: Context): Document {
    const idGenerator = new IdGenerator();
    const segments: Segment[] = [];
    const resJson = JSON.parse(res);
    const resMap = convertJsonToMap(resJson);
    const resKeys = Object.keys(resMap);

    const rows = resKeys.map((key) => {
      const value = String(resMap[key]);
      const id: string = idGenerator.generateId(value);

      segments.push({
        id,
        text: value || "",
      });

      const segmentNode = segment(id);

      return element("tr", [element("td", key), element("td", [segmentNode])]);
    });

    // Use hastscript to build the table
    // layout must be LayoutRoot (which extends HastRoot)
    const table = element("table", [element("tbody", rows)]);

    const layout: LayoutRoot = root([table]);

    return { segments, layout };
  }

  stringify(doc: Document, ctx?: Context): string {
    const segmentsMap: Record<string, Segment> = {};

    doc.segments.forEach((segment) => {
      segmentsMap[segment.id] = segment;
    });

    const rows: { key: string; value: string }[] = [];

    visitParents(
      doc.layout,
      (node): node is LayoutElement =>
        node.type === "element" && (node as LayoutElement).tagName === "tr",
      (element: LayoutElement) => {
        if (element.children.length === 2) {
          // We know structure is <tr><td>Key</td><td><SegmentNode/></td></tr>
          const keyTd = element.children[0];
          const valueTd = element.children[1];

          if (
            keyTd.type === "element" &&
            valueTd.type === "element" &&
            keyTd.children.length > 0 &&
            valueTd.children.length > 0
          ) {
            const keyNode = keyTd.children[0];
            const valueNode = valueTd.children[0];

            if (keyNode.type === "text" && valueNode.type === "segment") {
              const key = keyNode.value;
              const segment = segmentsMap[valueNode.id];
              if (segment) {
                rows.push({ key, value: segment.text });
              }
            }
          }
          return "skip";
        }
      },
    );

    return JSON.stringify(convertMapToJson(rows), null, 2);
  }
}
